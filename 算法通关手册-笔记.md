# 算法与复杂度
* 算法（Algorithm） 就是解决问题的方法或者过程。如果我们把问题看成是函数，那么算法就是将输入转换为输出的过程。
* 数据结构（Data Structure） 是数据的计算机表示和相应的一组操作。程序（Program） 则是算法和数据结构的具体实现。
* 数据结构可以分为 「逻辑结构」 和 「物理结构」。
  * 逻辑结构可分为：集合结构、线性结构、树形结构、图形结构
  * 物理结构可分为：顺序存储结构、链式存储结构。

* 算法拥有 5 个基本特性：输入、输出、有穷性、确定性、可行性。
* 算法追求的目标有 5 个：正确性、可读性、健壮性、所需运行时间更少（时间复杂度更低）、占用内存空间更小（空间复杂度更低）。
* 时间复杂度（Time Complexity）：在问题的输入规模为 n 的条件下，算法运行所需要花费的时间，可以记作为 T(n)。
* 时间复杂度（Time Complexity）：在问题的输入规模为 n 的条件下，算法运行所需要花费的时间，可以记作为 T(n)。
* 一般含有双层嵌套，且每层循环下的语句执行次数为 n 的算法涉及平方时间复杂度。这类算法随着问题规模 n 的增大，对应计算次数呈平方关系增长。
* 阶乘时间复杂度一般出现在与「全排列」、「旅行商问题暴力解法」相关的算法中。这类算法随着问题规模 n 的增大，对应计算次数呈阶乘关系增长。
* 对数时间复杂度一般出现在「二分查找」、「分治」这种一分为二的算法中。这类算法随着问题规模 n 的增大，对应的计算次数呈对数关系增长。
* 线性对数一般出现在排序算法中，例如「快速排序」、「归并排序」、「堆排序」等。这类算法随着问题规模 n 的增大，对应的计算次数呈线性对数关系增长。
* 空间复杂度（Space Complexity）：在问题的输入规模为 n 的条件下，算法所占用的空间大小，可以记作为 S(n)。一般将 算法的辅助空间 作为衡量空间复杂度的标准。
## 数组
* 「数组」 是实现线性表的顺序结构存储的基础。
* 数组在计算机中的表示，就是一片连续的存储单元。数组中的每一个数据元素都占有一定的存储单元，每个存储单元都有自己的内存地址，并且元素之间是紧密排列的。
* 计算机给一个数组分配了一组连续的存储空间，其中第一个元素开始的地址被称为 「首地址」。每个数据元素都有对应的下标索引和内存地址，计算机通过地址来访问数据元素。当计算机需要访问数组的某个元素时，会通过 「寻址公式」 计算出对应元素的内存地址，然后访问地址对应的数据元素。
* Python 中的 list 直接封装了尾部插入操作，直接调用 append 方法即可。
* 在数组第 i 个位置上插入值为 val 的元素：先检查插入下标 i 是否合法，即 0 <= i <=len(nums)。确定合法位置后，通常情况下第 i 个位置上已经有数据了（除非 i == len(nums) ），要把第 i 个位置到第 len(nums) - 1 位置上的元素依次向后移动，然后再在第 i 个元素位置插入 val 值，并更新数组的元素计数值。
* 删除元素分为三种情况：「删除数组尾部元素」、「删除数组第 i 个位置上的元素」、「基于条件删除元素」。
```
#Python对于列表的处理：
#增加元素
list.append(2)
#插入元素
list.insert(i, val)
#改变元素
list[i]=j
#删除i位置的元素，默认末尾
list.pop(i)
#查找元素并删除：
list.remove(5)
#开头加元素
[x]+list
#合并字符串元素
";".join(list)
```
* list字符分割
```
>>> li = ['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']
>>> s = ";".join(li)
>>> s'server=mpilgrim;uid=sa;database=master;pwd=secret'
>>> s.split(";") 
['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']
>>> s.split(";", 1)['server=mpilgrim', 'uid=sa;database=master;pwd=secret']
```
* split 接受一个可选的第二个参数, 它是要分割的次数。
### 冒泡排序算法步骤 
  * 先将序列中第 1 个元素与第 2 个元素进行比较，若前者大于后者，则两者交换位置，否则不交换；
  * 然后将第 2 个元素与第 3 个元素比较，若前者大于后者，则两者交换位置，否则不交换；
  * 依次类推，直到第 n - 1 个元素与第 n 个元素比较（或交换）为止。经过如此一趟排序，使得 n 个元素中值最大元素被安置在序列的第 n 个位置上。此后，再对前 n - 1 个元素进行同样过程，使得该 n - 1 个元素中值最大元素被安置在第 n - 1 个位置上。
  * 然后再对前 n - 2 个元素重复上述过程，直到某一趟排序过程中不出现元素交换位置的动作，排序结束。
 ### 选择排序
 * 每一趟排序中，从剩余未排序元素中选择一个最小的元素，与未排好序的元素最前面的那个元素交换位置。
 
```
class Solution:
    def selectionSort(self, arr):
        for i in range(len(arr) - 1):
            # 记录未排序序列中最小数的索引
            min_i = i
            for j in range(i + 1, len(arr)):
                if arr[j] < arr[min_i]:
                    min_i = j
            # 如果找到最小数，将 i 位置上元素与最小数位置上元素进行交换
            if i != min_i:
                arr[i], arr[min_i] = arr[min_i], arr[i]
        return arr

    def sortArray(self, nums: List[int]) -> List[int]:
        return self.selectionSort(nums)
```
### 插入排序
* 将整个序列切分为两部分：前 i - 1 个元素是有序序列，后 n - i + 1 个元素是无序序列。每一次排序，将无序序列的首元素，在有序序列中找到相应的位置并插入。
* 可以简述为：每一趟排序中，将剩余无序序列的第一个元素，插入到有序序列的适当位置上。
```
class Solution:
    def insertionSort(self, arr):
        for i in range(1, len(arr)):
            temp = arr[i]
            j = i
            while j > 0 and arr[j - 1] > temp:
                arr[j] = arr[j - 1]
                j -= 1
            arr[j] = temp

        return arr

    def sortArray(self, nums: List[int]) -> List[int]:
        return self.insertionSort(nums)
```
### 希尔排序
* 将整个序列切按照一定的间隔取值划分为若干个子序列，每个子序列分别进行插入排序。然后逐渐缩小间隔进行下一轮划分子序列和插入排序。直至最后一轮排序间隔为 1，对整个序列进行插入排序。
### 归并排序
* 采用经典的分治策略，先递归地将当前序列平均分成两半。然后将有序序列两两合并，最终合并成一个有序序列。
### 快速排序
* 通过一趟排序将无序序列分为独立的两个序列，第一个序列的值均比第二个序列的值小。然后递归地排列两个子序列，以达到整个序列有序。
* 快速排序算法步骤
  * 从数组中找到一个基准数。
  * 然后将数组中比基准数大的元素移动到基准数右侧，比他小的元素移动到基准数左侧，从而把数组拆分为左右两个部分。
  * 再对左右两个部分分别重复第二步，直到各个部分只有一个数，则排序结束。
* 「**二分查找算法**（Binary Search Algorithm）」，也叫做 「折半查找算法」、「对数查找算法」。是一种在有序数组中查找某一特定元素的搜索算法。基本算法思想：先确定待查找元素所在的区间范围，在逐步缩小范围，直到找到元素或找不到该元素为止。
* **双指针**（Two Pointers）：指的是在遍历元素的过程中，不是使用单个指针进行访问，而是使用两个指针进行访问，从而达到相应的目的。如果两个指针方向相反，则称为「对撞时针」。如果两个指针方向相同，则称为「快慢指针」。如果两个指针分别属于不同的数组 / 链表，则称为「分离双指针」。
* **滑动窗口**（Sliding Window）：在给定数组 / 字符串上维护一个固定长度或不定长度的窗口。可以对窗口进行滑动操作、缩放操作，以及维护最优解操作。
* 滑动操作：窗口可按照一定方向进行移动。最常见的是向右侧移动。
* 缩放操作：对于不定长度的窗口，可以从左侧缩小窗口长度，也可以从右侧增大窗口长度。
## 链表
* 链表（Linked List）：一种线性表数据结构。它使用一组任意的存储单元（可以是连续的，也可以是不连续的），来存储一组具有相同类型的数据。
* 优点：存储空间不必事先分配，在需要存储空间的时候可以临时申请，不会造成空间的浪费；一些操作的时间效率远比数组高（插入、移动、删除元素等）。
* 缺点：不仅数据元素本身的数据信息要占用存储空间，指针也需要占用存储空间，链表结构比数组结构的空间开销大。
* 双向链表（Doubly Linked List）：链表的一种，也叫做双链表。它的每个链节点中有两个指针，分别指向直接后继和直接前驱。
* 循环链表（Circular linked list）：链表的一种。它的最后一个链节点指向头节点，形成一个环。
* 在链表中查找值为 val 的位置：链表不能像数组那样进行随机访问，只能从头节点 head 开始，沿着链表一个一个节点逐一进行查找。如果查找成功，返回被查找节点的地址。否则返回 None。
* 而在单链表中，因为遍历节点只能顺着 next 指针方向进行，所以对于链表而言，一般只会用到「快慢指针」和「分离双指针」。其中链表的「快慢指针」又分为「**起点不一致的快慢指针**」和「**步长不一致的快慢指针**」。这几种类型的双指针所解决的问题也各不相同。下面我们一一进行讲解。
* 
